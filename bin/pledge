#!/usr/bin/env lua
require 'redis'
local redis = Redis.connect('127.0.0.1', 6379)

local zmq = require 'zmq'
zmq.threads = require 'zmq.threads'
local socket = require 'socket'

local context = zmq.init(1)

--  Socket to talk to primers
local primers = context:socket(zmq.PUSH)
primers:bind("inproc://primers")

local stalework = context:socket(zmq.PULL)
stalework:bind("inproc://stalework")

--  Launch pool of primer threads
local concurrency = ... or 1
local primer_pool = {}
for n = 1, concurrency do
    primer_pool[n] = zmq.threads.runfile(context, './bin/primer.lua', n)
    primer_pool[n]:start()
end

local sub_thread = zmq.threads.runfile(context, './bin/subscriber.lua')
sub_thread:start()


io.stdout:write("pledge 0.1 (ledge primer)\n\n")
io.stdout:write("Ready with " .. #primer_pool .. " threads...\n")
io.stdout:flush()

-- On the first load we'll push work out for all known expired URIs.
-- Work being done gets set to -1, and future iterations look >= 0 
-- to avoid repetition.
local min_time = "-inf"

-- Periodically ask Redis for expired items
while true do
    socket.sleep(1) -- Sleep first so that ZMQ has a chance.
    
    -- First see if we've been notified of any stale items
    local stale = stalework:recv(zmq.NOBLOCK)
    if (stale ~= nil) then
        primers:send(stale)
    end

    -- Look for expired items
    local expired = redis:zrangebyscore('ledge:uris_by_expiry', min_time, os.time())
    for i,uri in ipairs(expired) do
        redis:zadd('ledge:uris_by_expiry', -1, uri) 
        primers:send(uri)
    end

    min_time = 0 -- From now on, only get >= 0 scores.
end

--  We never get here but clean up anyhow
primers:close()
context:term()
